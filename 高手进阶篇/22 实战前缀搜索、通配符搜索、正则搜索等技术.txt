1、前缀搜索

C3D0-KD345
C3K5-DFG65
C4I8-UI365

搜索C3，希望把上面这两个都搜索出来，其实就吃根据字符串的前缀去搜索

GET my_index/my_type/_search
{
	"query" : {
		"prefix"  {
			"title" : {
				"value" : "C3"
			}
		}
	}
}

2、前缀搜索的原理

不计算分数，与prefix filter唯一的区别就是，filter会cache bitset

扫描整个倒排索引

前缀越短，要处理的doc越多，性能越差，尽可能用长前缀搜索

前缀搜索，它是怎么执行的？性能为什么差呢？

match：
C3D0-KD345
C3K5-DFG65
C4I8-UI365

每个字符串都需要被分词

C3 -->扫描倒排索引 -->一旦扫描到c3就可以停止 --> 没有必要继续去搜索其他term了

match性能往往是很高的

前缀搜索（不分词）：
C3 --> 先扫描到了C3D0-KD345，找到了一个前缀是C3的字符串 --> 还是要继续搜索的，因为后面还有一个C3K5-DFG65，也许还有其他很多的前缀带C3的字符串 --> 扫描到了一个前缀匹配的term，不能停，必须继续搜索 --> 直接扫描完整个的倒排索引，才能结束

prefix性能很差

3、通配符搜索

跟前缀搜索类似，功能更加强大

C3D0-KD345
C3K5-DFG65
C4I8-UI365

5字符-D任意个字符5

5?-*5：通配符去表达更加复杂的模糊搜索的语义

GET my_index/my_type/_search
{
  "query": {
    "wildcard": {
      "title": {
        "value": "5?-*5"
      }
    }
  }
}

？：任意字符
*：任意多个字符

性能一样差，必须扫描整个倒排索引才能找到。

4、正则搜索

GET my_index/my_type/_search
{
  "query": {
    "regexp" : {
      "title" : "c[0-9].+"
    }
  }
}

[0-9]：指定范围的一个数字
[a-z]：指定范围的一个字母

.：一个字符
+：前面的正则表达式可以出现一次或多次

wildcard和regexp，与prefix原理一致，都会扫描整个索引，性能很差

主要是给大家介绍一些高级的搜索语法。在实际应用中，能不用尽量别用，性能太差了。

前缀搜索有一个大幅度提升性能的n-gram机制